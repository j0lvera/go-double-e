// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
     WITH credit_account AS (SELECT id
                               FROM accounts
                              WHERE accounts.uuid = $5::text),
          debit_account AS (SELECT id
                              FROM accounts
                             WHERE accounts.uuid = $6::text),
          ledger_id AS (SELECT id
                          FROM ledgers
                         WHERE ledgers.uuid = $7::text)
   INSERT
     INTO transactions (amount,
                        date,
                        description,
                        metadata,
                        credit_account_id,
                        debit_account_id,
                        ledger_id)
   VALUES ($1::bigint,
           $2::date,
           $3::text,
           $4::jsonb,
           (SELECT id FROM credit_account),
           (SELECT id FROM debit_account),
           (SELECT id FROM ledger_id))
RETURNING id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
`

type CreateTransactionParams struct {
	Amount            int64
	Date              pgtype.Date
	Description       string
	Metadata          []byte
	CreditAccountUuid string
	DebitAccountUuid  string
	LedgerUuid        string
}

// CreateTransaction
//
//	     WITH credit_account AS (SELECT id
//	                               FROM accounts
//	                              WHERE accounts.uuid = $5::text),
//	          debit_account AS (SELECT id
//	                              FROM accounts
//	                             WHERE accounts.uuid = $6::text),
//	          ledger_id AS (SELECT id
//	                          FROM ledgers
//	                         WHERE ledgers.uuid = $7::text)
//	   INSERT
//	     INTO transactions (amount,
//	                        date,
//	                        description,
//	                        metadata,
//	                        credit_account_id,
//	                        debit_account_id,
//	                        ledger_id)
//	   VALUES ($1::bigint,
//	           $2::date,
//	           $3::text,
//	           $4::jsonb,
//	           (SELECT id FROM credit_account),
//	           (SELECT id FROM debit_account),
//	           (SELECT id FROM ledger_id))
//	RETURNING id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.Date,
		arg.Description,
		arg.Metadata,
		arg.CreditAccountUuid,
		arg.DebitAccountUuid,
		arg.LedgerUuid,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
delete
  from transactions
 where uuid = $1
`

// DeleteTransaction
//
//	delete
//	  from transactions
//	 where uuid = $1
func (q *Queries) DeleteTransaction(ctx context.Context, uuid string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, uuid)
	return err
}

const getTransaction = `-- name: GetTransaction :one
select id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
  from transactions
 where id = $1
 limit 1
`

// GetTransaction
//
//	select id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
//	  from transactions
//	 where id = $1
//	 limit 1
func (q *Queries) GetTransaction(ctx context.Context, id int64) (*Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}

const listTransactions = `-- name: ListTransactions :many
  with ledger as (select id from ledgers where uuid = $2::text)
select uuid, amount, date, description, metadata
  from transactions
 where ledger_id = (select id from ledger)
   and metadata @> $1::jsonb
`

type ListTransactionsParams struct {
	Metadata   []byte
	LedgerUuid string
}

type ListTransactionsRow struct {
	Uuid        string
	Amount      int64
	Date        pgtype.Date
	Description pgtype.Text
	Metadata    []byte
}

// ListTransactions
//
//	  with ledger as (select id from ledgers where uuid = $2::text)
//	select uuid, amount, date, description, metadata
//	  from transactions
//	 where ledger_id = (select id from ledger)
//	   and metadata @> $1::jsonb
func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]*ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions, arg.Metadata, arg.LedgerUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Amount,
			&i.Date,
			&i.Description,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
     with credit_account as (select id from accounts where accounts.uuid = $6::text),
          debit_account as (select id from accounts where accounts.uuid = $7::text),
          ledger as (select id from ledgers where ledgers.uuid = $8::text)
   update transactions
      set amount            = coalesce($1::bigint, amount),
          date              = coalesce($2, date),
          description       = coalesce($3, description),
          metadata          = coalesce($4, metadata),
          credit_account_id = coalesce((select id from credit_account), credit_account_id),
          debit_account_id  = coalesce((select id from debit_account), debit_account_id),
          ledger_id         = coalesce((select id from ledger), ledger_id)
    where transactions.uuid = $5
returning id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
`

type UpdateTransactionParams struct {
	Amount            pgtype.Int8
	Date              pgtype.Date
	Description       pgtype.Text
	Metadata          []byte
	Uuid              string
	CreditAccountUuid pgtype.Text
	DebitAccountUuid  pgtype.Text
	LedgerUuid        pgtype.Text
}

// UpdateTransaction
//
//	     with credit_account as (select id from accounts where accounts.uuid = $6::text),
//	          debit_account as (select id from accounts where accounts.uuid = $7::text),
//	          ledger as (select id from ledgers where ledgers.uuid = $8::text)
//	   update transactions
//	      set amount            = coalesce($1::bigint, amount),
//	          date              = coalesce($2, date),
//	          description       = coalesce($3, description),
//	          metadata          = coalesce($4, metadata),
//	          credit_account_id = coalesce((select id from credit_account), credit_account_id),
//	          debit_account_id  = coalesce((select id from debit_account), debit_account_id),
//	          ledger_id         = coalesce((select id from ledger), ledger_id)
//	    where transactions.uuid = $5
//	returning id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.Amount,
		arg.Date,
		arg.Description,
		arg.Metadata,
		arg.Uuid,
		arg.CreditAccountUuid,
		arg.DebitAccountUuid,
		arg.LedgerUuid,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}
