// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
     WITH credit_account AS (SELECT id
                               FROM accounts
                              WHERE accounts.uuid = $5::text),
          debit_account AS (SELECT id
                              FROM accounts
                             WHERE accounts.uuid = $6::text),
          ledger_id AS (SELECT id
                          FROM ledgers
                         WHERE ledgers.uuid = $7::text)
   INSERT
     INTO transactions (amount,
                        date,
                        description,
                        metadata,
                        credit_account_id,
                        debit_account_id,
                        ledger_id)
   VALUES ($1::bigint,
           $2::date,
           $3::text,
           $4::jsonb,
           (SELECT id FROM credit_account),
           (SELECT id FROM debit_account),
           (SELECT id FROM ledger_id))
RETURNING id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
`

type CreateTransactionParams struct {
	Amount            int64       `json:"amount"`
	Date              pgtype.Date `json:"date"`
	Description       string      `json:"description"`
	Metadata          []byte      `json:"metadata"`
	CreditAccountUuid string      `json:"creditAccountUuid"`
	DebitAccountUuid  string      `json:"debitAccountUuid"`
	LedgerUuid        string      `json:"ledgerUuid"`
}

// CreateTransaction
//
//	     WITH credit_account AS (SELECT id
//	                               FROM accounts
//	                              WHERE accounts.uuid = $5::text),
//	          debit_account AS (SELECT id
//	                              FROM accounts
//	                             WHERE accounts.uuid = $6::text),
//	          ledger_id AS (SELECT id
//	                          FROM ledgers
//	                         WHERE ledgers.uuid = $7::text)
//	   INSERT
//	     INTO transactions (amount,
//	                        date,
//	                        description,
//	                        metadata,
//	                        credit_account_id,
//	                        debit_account_id,
//	                        ledger_id)
//	   VALUES ($1::bigint,
//	           $2::date,
//	           $3::text,
//	           $4::jsonb,
//	           (SELECT id FROM credit_account),
//	           (SELECT id FROM debit_account),
//	           (SELECT id FROM ledger_id))
//	RETURNING id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.Date,
		arg.Description,
		arg.Metadata,
		arg.CreditAccountUuid,
		arg.DebitAccountUuid,
		arg.LedgerUuid,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
delete
  from transactions
 where uuid = $1::text
`

// DeleteTransaction
//
//	delete
//	  from transactions
//	 where uuid = $1::text
func (q *Queries) DeleteTransaction(ctx context.Context, uuid string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, uuid)
	return err
}

const getTransaction = `-- name: GetTransaction :one
select id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
  from transactions
 where uuid = $1::text
 limit 1
`

// GetTransaction
//
//	select id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
//	  from transactions
//	 where uuid = $1::text
//	 limit 1
func (q *Queries) GetTransaction(ctx context.Context, uuid string) (*Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, uuid)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}

const getTransactionsCount = `-- name: GetTransactionsCount :one
  with ledger as (select ledgers.id from ledgers where ledgers.uuid = $2::text)
select count(*)
  from transactions
 where ledger_id = (select id from ledger)
   and metadata @> $1::jsonb
`

type GetTransactionsCountParams struct {
	Metadata   []byte `json:"metadata"`
	LedgerUuid string `json:"ledgerUuid"`
}

// GetTransactionsCount
//
//	  with ledger as (select ledgers.id from ledgers where ledgers.uuid = $2::text)
//	select count(*)
//	  from transactions
//	 where ledger_id = (select id from ledger)
//	   and metadata @> $1::jsonb
func (q *Queries) GetTransactionsCount(ctx context.Context, arg GetTransactionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTransactionsCount, arg.Metadata, arg.LedgerUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listTransactions = `-- name: ListTransactions :many
  with ledger as (select ledgers.id from ledgers where ledgers.uuid = $4::text)
select uuid,
       amount,
       date,
       description,
       metadata #>> '{}' AS metadata
  from transactions
 where ledger_id = (select id from ledger)
   and metadata @> $1::jsonb
 order by created_at desc
 limit $3 offset $2
`

type ListTransactionsParams struct {
	Metadata   []byte `json:"metadata"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
	LedgerUuid string `json:"ledgerUuid"`
}

type ListTransactionsRow struct {
	Uuid        string      `json:"uuid"`
	Amount      int64       `json:"amount"`
	Date        pgtype.Date `json:"date"`
	Description pgtype.Text `json:"description"`
	Metadata    interface{} `json:"metadata"`
}

// ListTransactions
//
//	  with ledger as (select ledgers.id from ledgers where ledgers.uuid = $4::text)
//	select uuid,
//	       amount,
//	       date,
//	       description,
//	       metadata #>> '{}' AS metadata
//	  from transactions
//	 where ledger_id = (select id from ledger)
//	   and metadata @> $1::jsonb
//	 order by created_at desc
//	 limit $3 offset $2
func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]*ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.Metadata,
		arg.Offset,
		arg.Limit,
		arg.LedgerUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTransactionsRow
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Amount,
			&i.Date,
			&i.Description,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
     with credit_account as (select id from accounts where accounts.uuid = $6::text),
          debit_account as (select id from accounts where accounts.uuid = $7::text),
          ledger as (select id from ledgers where ledgers.uuid = $8::text)
   update transactions
      set amount            = coalesce($1::bigint, amount),
          date              = coalesce($2, date),
          description       = coalesce($3, description),
          metadata          = coalesce($4, metadata),
          credit_account_id = coalesce((select id from credit_account), credit_account_id),
          debit_account_id  = coalesce((select id from debit_account), debit_account_id),
          ledger_id         = coalesce((select id from ledger), ledger_id)
    where transactions.uuid = $5
returning id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
`

type UpdateTransactionParams struct {
	Amount            pgtype.Int8 `json:"amount"`
	Date              pgtype.Date `json:"date"`
	Description       pgtype.Text `json:"description"`
	Metadata          []byte      `json:"metadata"`
	Uuid              string      `json:"uuid"`
	CreditAccountUuid pgtype.Text `json:"creditAccountUuid"`
	DebitAccountUuid  pgtype.Text `json:"debitAccountUuid"`
	LedgerUuid        pgtype.Text `json:"ledgerUuid"`
}

// UpdateTransaction
//
//	     with credit_account as (select id from accounts where accounts.uuid = $6::text),
//	          debit_account as (select id from accounts where accounts.uuid = $7::text),
//	          ledger as (select id from ledgers where ledgers.uuid = $8::text)
//	   update transactions
//	      set amount            = coalesce($1::bigint, amount),
//	          date              = coalesce($2, date),
//	          description       = coalesce($3, description),
//	          metadata          = coalesce($4, metadata),
//	          credit_account_id = coalesce((select id from credit_account), credit_account_id),
//	          debit_account_id  = coalesce((select id from debit_account), debit_account_id),
//	          ledger_id         = coalesce((select id from ledger), ledger_id)
//	    where transactions.uuid = $5
//	returning id, uuid, created_at, updated_at, amount, date, description, metadata, credit_account_id, debit_account_id, ledger_id
func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.Amount,
		arg.Date,
		arg.Description,
		arg.Metadata,
		arg.Uuid,
		arg.CreditAccountUuid,
		arg.DebitAccountUuid,
		arg.LedgerUuid,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Date,
		&i.Description,
		&i.Metadata,
		&i.CreditAccountID,
		&i.DebitAccountID,
		&i.LedgerID,
	)
	return &i, err
}
